##  A function to take two continuous and one-two "level" predictors, and return a nice set of contour plots, from a glm() model object.
##
##
##
##  BLN, 23 Aug 2017
########################################################################33
##
##  Depends: lattice, latticeExtra
##
##
##  cplot (mod, focal.preds, focal.nms, cond.preds, cond.nms, quants = c(0.1, 0.5, 0.9), plot.title, file.nm)
##
##
##  Description:
## --------------
##  cplot() makes pretty contour plots using two "focal predictors, across levels of one or two "conditioning predictors."  It takes as input a model object with glm() (it could easily be altered to accommodate any object class that has a predict() method).  The model needs to have at least two continous predictors, and one or more predictors across whose "levels" you'd like to produce separate contour plots.  These levels could be 1) true factor levels, 2) the two values of a 0/1 binary variable, or 3) quantiles of a continuous predictor.
##  The set of plots is saved to a PNG file **in the present working directory** (so be sure to set this with setwd() first!). 
##
##  Arguments:
##---------------
##  mod          -- A model object generated by glm().
##  
##  focal.preds  -- A character vector of length 2, giving the names of the continuous predictors you want to use to generate each contour plot.  Names must match those used for the predictors in the model object!
##
##  focal.nms    -- A character vector of length 2, giving nice-looking names for the focal predictors, to appear in the plots.
##
##  cond.preds   -- A character vector of length 1 or 2, giving the names of the "conditioning predictors" across whose levels you want to look.  Names must match those used for the predictors in the model object!
##
##  cond.nms     -- A character vector, giving nice-looking names for the conditioning predictors, to appear in the plots.
##
##  quants       -- Vector of quantiles, for use in selecting values of continuous conditioning predictor(s).
##
##  plot.title   -- Title to print on the plot.
##
##  file.nm      -- Basename for the output PNG file.  If empty, inherits the value of plot.title. 
##
##  png.res      -- Resolution of the output PNG file.
##
##  inch         -- Base image size in inches.  This value is multiplied by the number of rows and columns in the plot, respectively, to determine the size of the image.
##
##  add.letters  -- Optionally add capital letters to each panel of the plot.
##
##
##
##  Example:
##---------------
##  gt <- read.csv('/your/path/to/burrows_pseudoabs_02jun2017.csv', stringsAsFactors=F)[1:9444,]
##  gt$gt <- ifelse(gt$type == "burrow", 1, 0)
##  gt$pndfld <- ifelse(gt$pondfreqcl == "None" & gt$flodfreqcl == "None", 0, 1)
##  mod <- glm(gt ~ sandtotal_r*new_suit + I(new_suit^2) + e_utm17 + pndfld, family="binomial", data = gt)
##  setwd("/your/path/to/images")
##  cplot(mod=mod,
##        focal.preds=c("e_utm17", "new_suit"),
##        focal.nms=c("Easting", "Soil suitability"),
##        cond.preds=c("sandtotal_r", "pndfld"),
##        cond.nms=c("% sand", "Ponding / Flooding"),
##        plot.title="",
##        file.nm="test", add.letters=T) 
##
##
##  Function Definition:
##------------------------
cplot <- function(mod, focal.preds, focal.nms, use.whole.range = T, focal.quants, cond.preds, cond.nms, cond.fac.ordr, cond.fac.nms, cond.quants=c(0.1,0.5,0.9), plot.title, file.nm, png.res=300, inch=4, add.letters=F) {

  stopifnot("glm" %in% class(mod))
  stopifnot(cond.preds %in% attr(mod$terms, "term.labels"))

  require(lattice)
  require(latticeExtra)

  if (!exists("file.nm")) { file.nm <- plot.title }

  if ( length(focal.preds) != 2) { stop("You need two-and-only-two continuous predictors!") }  
  if ( length(cond.preds) > 2) { stop("At most two quantile / categorical predictorz!") }  

### 'cond.fac.nms' should be transformed into a list, if it isn't one:
  if (is.character(cond.fac.nms)) {
    cond.fac.nms <- list(cond.fac.nms)
  }
  
  response <- mod$terms[[2]]  
  cf <- coef(mod)

  lvls <- list()
  lvl.fac <- lvl.type <- c()
  
  for (i in 1:length(cond.preds)) {
    lvl.fac[i] <- class(mod$data[,cond.preds[i]]) == "factor" || all(unique(mod$data[,cond.preds[i]]) %in% c(0,1))  
    if(lvl.fac[i]) { 
      if (class(mod$data[,cond.preds[i]]) == "factor") {
        lvl.type[i] <- "fac"
        if (exists("cond.fac.ordr")) { mod$data[,cond.preds[i]] <- factor(mod$data[,cond.preds[i]], levels = cond.fac.ordr[[i]]) }
        lvls[[i]] <- levels(mod$data[,cond.preds[i]])      
        } else {
        if (all(unique(mod$data[,cond.preds[i]]) %in% c(0,1))) {
          lvl.type[i] <- "bin"
          lvls[[i]] <- c(0,1)
          } else {
          stop("Nope! 'cond.pred' must be a factor, or binary (0/1).")
          }
        }
     } else {
       lvls[[i]] <- signif(quantile(mod$model[,match(cond.preds[i], names(mod$model))], probs=cond.quants),2)
       lvl.type[i] <- "quant"
     }
   }

#  continuous predictors:
  focal.vars <- mod$model[match(focal.preds, names(mod$model))]
  focal.rng <- if (use.whole.range) { lapply(focal.vars, FUN=range) } else { lapply(focal.vars, FUN = quantile, probs = focal.quants) }
  focal.mn <- lapply(focal.vars, FUN=mean)
  
  seq.fun <- function(v) {
    seq(from=v[1], to=v[2], length.out=100)
  }
  
  focal.pre <- as.data.frame(lapply(focal.rng, FUN=seq.fun))
  focal.vals <- cbind(rep(focal.pre[,1], each=100), rep(focal.pre[,2], times=100))

#  response <- mod$terms[[2]]  
#  cf <- coef(mod)
  trms <- names(attr(terms(mod), "dataClasses"))

  main <- trms[trms != response & !grepl(x=trms, pattern="I\\(.*\\^2\\)") & !grepl(x=trms, pattern=".*:.*")]
  
  other.main <- main[!main %in% c(focal.preds, cond.preds)]

  mn <- c()
  if (length(other.main) > 0) {
    mn <- numeric()
    for (i in 1:length(other.main)) {
      mn[i] <- mean(mod$model[,other.main[i]])
      names(mn)[i] <- other.main[i] 
    }
  focal.df <- as.data.frame(cbind(focal.vals, as.data.frame(matrix(mn, nrow = 1, byrow = T))))
  }  else {
  focal.df <- as.data.frame(focal.vals)
  }

pred.df <- focal.df
for (j in 1:length(lvls)) {
  for (i in 1:length(lvls[[j]])) {
    if (i == 1) {
      pred.df <- cbind(pred.df, lvls[[j]][i])
      names(pred.df) <- c(focal.preds, other.main, cond.preds[1:j])
    } else {
    ### 14 Sep 2018 -- changing this line:
#      tmp.df <- cbind(pred.df[,-dim(pred.df)[2]], lvls[[j]][i])     
      tmp.df <- cbind(pred.df[1:(dim(focal.df)[1]*j),-dim(pred.df)[2]], lvls[[j]][i])
      names(tmp.df) <- names(pred.df)
      pred.df <- rbind(pred.df, tmp.df)
    }    
  }
}
  
  pred.vals <- round(predict(mod, newdata=pred.df, type="response"),6)
 
  pred <- cbind(pred.vals, pred.df)

####  PLOT PLOT PLOT
#paste(cond.preds[2], lvls[[2]], sep = "_")

rmp1 <- c("grey30", "lemonchiffon")
rmp2 <- c("grey30", "lightgreen")
cr <- colorRamp(colors = rmp1)

cr(seq(0,1,by = 0.01))/255 -> ramp
cols <- rgb(ramp[,1], ramp[,2], ramp[,3])

form <- paste("pred.vals ~", paste(focal.preds, collapse = " * "), "|", paste(cond.preds, collapse=" * "))     

for (i in 1:length(cond.preds)) {
  tmp.df <- data.frame(val = as.character(pred[,names(pred) == cond.preds[i]]), stringsAsFactors = F)
  tbl <- data.frame(lvls = lvls[[i]], nms = cond.fac.nms[[i]], stringsAsFactors = F)
  jn <- merge(x = tmp.df, y = tbl, by.x = "val", by.y = "lvls", all.x = T, sort = F)
  facts <- paste(cond.nms[i], jn$nms, sep = ": ")
  pred[,names(pred) == cond.preds[i]] <- factor(facts, levels = unique(facts))
}

#  if (exists("sub")) {
#    for (i in 1:length(sub)) {
#      focal.nms <- gsub(focal.nms, pattern = sub[[i]][1], replace = sub[[i]][2], fixed = T)
#    }
#  }
  
#for (j in 1:length(lvls[[2]])) {   ## loop over levels of page.pred
h <- ifelse(length(lvls) > 1, length(lvls[[2]]), 1.3)

  png(file = paste(file.nm, "_", Sys.Date(), ".png", sep = ""),
        height = inch*h, width = inch*length(lvls[[1]]), units = "in",
        res = png.res)
        
    cp <- contourplot(formula(form),
            groups=cond.preds,
            data = pred,
            aspect=1, colorkey=FALSE, region=TRUE, xlim=focal.rng[[1]], ylim=focal.rng[[2]],
            xlab=list(label=focal.nms[1]),
            ylab=list(label=focal.nms[2]),
            at = seq(0,1,0.1),
            main = plot.title,
#            strip = function(..., cond.nms, cond.fac.nms) { strip.default(sep = ":", var.name = cond.nms, factor.levels = cond.fac.nms) },
            col.regions = cols,
            useRaster=T,
            between = list(x = 2))
            
  print(cp)

  if (add.letters) {
    row.num <- ifelse(length(lvls) > 1, length(lvls[[2]]):1, 1)
    row.v <- row.num:1
    col.num <- length(lvls[[1]])
    for (k in rev(row.v)) {
      for (j in 1:col.num) {
        trellis.focus(name = "panel", column = j, row = row.v[k])
        panel.text(y = focal.rng[[2]][1] + 0.1*(focal.rng[[2]][2]-focal.rng[[2]][1]), x = focal.rng[[1]][1] + 0.1*(focal.rng[[1]][2]-focal.rng[[1]][1]), labels = LETTERS[(k-1)*col.num+j], col = "white", cex = 2)
      }
    }
    trellis.unfocus()
  }

  dev.off()
  return(lvls)
}

